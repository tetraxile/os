; boot.asm - stage 1 bootloader
; this file consists of the bootsector of the hard disk, which is an MBR (master boot record).
; it is loaded by the BIOS at physical address 0x7c00, and the BIOS jumps to the beginning of it
; just before handing control to us. there are 0x1b8 bytes available for this stage of the bootloader,
; so it's important to load the next bootloader stage in here, which will be jumped to afterwards.

; the CPU is in real mode (16-bit) when the BIOS jumps here
use16
org 0x7c00

; stage 2 bootloader will be loaded into memory immediately after this bootsector
BOOT_STAGE_2_ADDR = 0x7e00

; memory map generated by int 15h/ax=e820h will be stored here, prefixed by a u32 number of entries
MEMORY_MAP_ADDR = 0x2000

start:
    ; BIOS sets dl to the "drive number" that the MBR was loaded from.
    ; it should be saved in order to load more sectors from this same drive
    mov [drive_number], dl

    cli ; disable interrupts for now
    cld ; set direction flag to auto-increment

    ; set video mode to 80x25 4-bit color text (mode 0x03)
    mov al, 0x03
    mov ah, 0x00
    int 0x10

    ; disable cursor (set bit 5 of ch)
    mov ch, 00100000b
    mov ah, 0x01
    int 0x10

    ; set up the stack, and set segment registers to 0
    xor ax, ax
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov sp, 0x7c00

    call generate_memory_map

    ; load bootloader stage 2 and kernel into memory
    mov si, dap.boot_stage_2
    call read_sectors_from_disk

    mov si, dap.kernel
    call read_sectors_from_disk

    jmp BOOT_STAGE_2_ADDR


; read a contiguous group of sectors from the boot drive
; * si - pointer to disk address packet (DAP)
read_sectors_from_disk:
    mov dl, [drive_number]
    mov ah, 0x42 ; extended read sectors
    int 0x13
    jc .disk_error
    cmp ah, 0
    jnz .disk_error
    ret

.disk_error:
    mov bp, strings.disk_error
    call bios_print_string
    hlt


; generate a map of the available memory using BIOS interrupt 15h/ax=e820h
; and store it at address 0x2000, prefixed by the number of map entries (u32)
; the map consists of entries of 24 bytes: a u64 base address, u64 length, u32 type, and u32 acpi attributes.
;
; int 15h/ax=e820h - get system memory map
; * ebx: continuation value (initially zero)
; * ecx: size of buffer (>= 20 bytes)
; * edx: 'SMAP'
; * es:di: buffer to store entry
; (out) carry flag clear if no error
; (out) eax: 'SMAP' if correct BIOS revision
; (out) ebx: continuation value (to be used in future e820 calls)
; (out) ecx: actual size of entry written
; (out) es:di: same address as input, buffer filled
generate_memory_map:
    push edi
    push ebx
    push bp

    mov di, MEMORY_MAP_ADDR+4
    xor bp, bp ; entry count

    mov dword [es:di + 20], 1
    xor ebx, ebx
    mov ecx, 24
    mov edx, 0x534d4150 ; 'SMAP'
    mov eax, 0xe820
    int 0x15

    jc .failed
    mov edx, 0x534d4150 ; 'SMAP'
    cmp eax, edx
    jne .failed
    test ebx, ebx
    jz .failed
    jmp .check_skip

.loop:
    mov dword [es:di + 20], 1
    mov ecx, 24
    mov eax, 0xe820
    int 0x15

    jc .end
    mov edx, 0x534d4150

.check_skip:
    jcxz .skip_entry ; skip entry if length = 0
    cmp cl, 20       ; check if response contains ACPI
    jbe .no_acpi
    test byte [es:di + 20], 1 ; if ACPI, skip if entry should be ignored
    je .skip_entry

.no_acpi:
    mov ecx, [es:di + 8]
    or ecx, [es:di + 12]
    jz .skip_entry ; skip if memory region length is zero
    inc bp         ; valid entry, increment counter...
    add di, 24     ; ...and move pointer to next entry

.skip_entry:
    test ebx, ebx ; if continuation byte is zero, list is complete
    jnz .loop

.end:
    mov [MEMORY_MAP_ADDR], bp ; store entry count

    pop bp
    pop ebx
    pop edi
    cli ; e820 sets interrupt flag again on some BIOSes for whatever reason
    ret

.failed:
    mov bp, strings.memory_map_error
    call bios_print_string
    hlt


; write a cp437 string to the VGA text buffer at the cursor and move to the next line
; * bp - pointer to string, prefixed with length (1 byte)
bios_print_string:
    ; get length from string
    movzx cx, byte [es:bp]
    inc bp

    mov ah, 0x13       ; print string interrupt
    mov al, 0x00       ; attribute in bl, don't move cursor
    mov bh, 0x00       ; display page 0
    mov bl, 0x0f       ; white text on black background
    mov dh, [cursor_y]
    mov dl, 0          ; move cursor to start of line
    int 0x10

    ; move the cursor to the next line
    inc byte [cursor_y]
    ret


cursor_y db 0
drive_number db 0

strings:
.disk_error db 10, "disk error"
.memory_map_error db 16, "memory map error"
.no_cpuid db 8, "no CPUID"
.no_long_mode db 12, "no long mode"

; pad the rest of this section with zeroes
times 0x198-($-$$) db 0

; disk address packets (https://en.wikipedia.org/wiki/INT_13H#INT_13h_AH=42h:_Extended_Read_Sectors_From_Drive)
; offset | size | description
;  0x00  |   1  | size of DAP (always 0x10)
;  0x01  |   1  | unused (always zero)
;  0x02  |   2  | number of sectors to read
;  0x04  |   4  | segment:offset pointer to write memory buffer
;  0x08  |   8  | LBA first sector
dap:
.boot_stage_2:
    db 0x10
    db 0
    dw 0x2        ; read 2 sectors
    dd 0x00007e00 ; write to 0x7e00
    dq 1          ; sectors starting at block 1

.kernel:
    db 0x10
    db 0
    dw 0x20       ; read 0x20 sectors
    dd 0x10000000 ; write to 0x10000
    dq 3          ; sectors starting at block 3

times 0x1b8-($-$$) db 0

dd 0xdead1979 ; disk signature
dw 0x0000     ; reserved

; MBR partition table (4 entries)
; offset | size | description
;  0x00  |   1  | 0x80 = active/bootable
;  0x01  |   3  | CHS first sector (8b head, 6b sector, 10b cylinder)
;  0x04  |   1  | system ID (denotes filesystem used)
;  0x05  |   3  | CHS last sector (same format as above)
;  0x08  |   4  | LBA first sector
;  0x0c  |   4  | number of sectors

; partition entry 1
db 0x80             ; active/bootable parition
db 0xff, 0xff, 0xff ; drive larger than 8GB -> set CHS to (1023:255:63)
db 0x7f             ; type = custom FS
db 0xff, 0xff, 0xff ; same as start CHS
dd 0x00000800       ; LBA first sector
dd 0x01cdec00       ; number of sectors

times 16 db 0 ; partition entry 2
times 16 db 0 ; partition entry 3
times 16 db 0 ; partition entry 4

dw 0xaa55 ; boot signature

include "src/boot_stage_2.asm"
