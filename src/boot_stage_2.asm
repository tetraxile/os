; boot_stage_2.asm - stage 2 bootloader

; memory map generated by int 15h/ax=e820h will be stored here, prefixed by a u32 number of entries
MEMORY_MAP_ADDR = 0x2000

start_stage_2:
    call generate_memory_map
    call check_cpuid

.enter_protected_mode:
    ; copy the GDT to address 0x800
    mov si, GDT_start
    mov di, 0x800
    mov cx, GDT_SIZE
    rep movsb

    lgdt [GDT_descriptor]
    lidt [IDT_descriptor]

    ; set cr0.PE (bit 0)
    mov eax, cr0
    or eax, 0x0001
    mov cr0, eax

    ; far jump to reload cs register
    jmp CODE_SEGMENT:.reload_cs

use32
.reload_cs:
    mov ax, DATA_SEGMENT
    mov ds, ax
    mov ss, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; set up kernel stack
    mov ebp, 0x90000
    mov esp, ebp

    jmp KERNEL_ADDR
use16

; check if the `cpuid` instruction is supported, and whether the LM (long mode) flag is set.
; errors if either one fails.
check_cpuid:
    ; check if cpuid is supported
    pushfd
    pushfd
    xor dword [esp], 0x00200000
    popfd
    pushfd
    pop eax
    xor eax, [esp]
    popfd
    and eax, 0x00200000
    jz .no_cpuid

    ; check if cpuid 0x80000001 is available
    mov eax, 0x80000000
    cpuid
    cmp eax, 0x80000001
    jb .no_long_mode

    ; check if cpuid.LM (flag 29) is set 
    mov eax, 0x80000001
    cpuid
    test edx, 0x20000000 ; 1 << 29
    jz .no_long_mode

    ret

.no_cpuid:
    mov bp, strings.no_cpuid
    call bios_print_string
    hlt

.no_long_mode:
    mov bp, strings.no_long_mode
    call bios_print_string
    hlt


; generate a map of the available memory using BIOS interrupt 15h/ax=e820h
; and store it at address 0x2000, prefixed by the number of map entries (u32)
; the map consists of entries of 24 bytes: a u64 base address, u64 length, u32 type, and u32 acpi attributes.
;
; int 15h/ax=e820h - get system memory map
; * ebx: continuation value (initially zero)
; * ecx: size of buffer (>= 20 bytes)
; * edx: 'SMAP'
; * es:di: buffer to store entry
; (out) carry flag clear if no error
; (out) eax: 'SMAP' if correct BIOS revision
; (out) ebx: continuation value (to be used in future e820 calls)
; (out) ecx: actual size of entry written
; (out) es:di: same address as input, buffer filled
generate_memory_map:
    push edi
    push ebx
    push bp

    mov di, MEMORY_MAP_ADDR+4
    xor bp, bp ; entry count

    mov dword [es:di + 20], 1
    xor ebx, ebx
    mov ecx, 24
    mov edx, 0x534d4150 ; 'SMAP'
    mov eax, 0xe820
    int 0x15

    jc .failed
    mov edx, 0x534d4150 ; 'SMAP'
    cmp eax, edx
    jne .failed
    test ebx, ebx
    jz .failed
    jmp .check_skip

.loop:
    mov dword [es:di + 20], 1
    mov ecx, 24
    mov eax, 0xe820
    int 0x15

    jc .end
    mov edx, 0x534d4150

.check_skip:
    jcxz .skip_entry ; skip entry if length = 0
    cmp cl, 20       ; check if response contains ACPI
    jbe .no_acpi
    test byte [es:di + 20], 1 ; if ACPI, skip if entry should be ignored
    je .skip_entry

.no_acpi:
    mov ecx, [es:di + 8]
    or ecx, [es:di + 12]
    jz .skip_entry ; skip if memory region length is zero
    inc bp         ; valid entry, increment counter...
    add di, 24     ; ...and move pointer to next entry

.skip_entry:
    test ebx, ebx ; if continuation byte is zero, list is complete
    jnz .loop

.end:
    mov [MEMORY_MAP_ADDR], bp ; store entry count

    pop bp
    pop ebx
    pop edi
    cli ; e820 sets interrupt flag again on some BIOSes for whatever reason
    ret

.failed:
    mov bp, strings.memory_map_error
    call bios_print_string
    hlt


include "src/gdt.asm"

GDT_descriptor:
    dw GDT_SIZE - 1 ; size
    dd 0x800        ; offset

IDT_descriptor:
    dw 0x800 ; size
    dd 0x0   ; offset

times 0x600-($-$$) db 0
